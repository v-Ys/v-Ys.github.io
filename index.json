[{"content":"","date":"2023-11-29","permalink":"/blog/","section":"Blog","summary":"","title":"Blog"},{"content":"","date":"2023-11-29","permalink":"/tags/make/","section":"Tags","summary":"","title":"make"},{"content":"","date":"2023-11-29","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":" 配置使用 # 在你的 bolg 仓库下新建一个 Makefile 文件，拷贝下面的代码进去，每次写完在 blog 仓库下执行make就行，（make 一般都预装的吧，应该不需要额外安装:） 优点方便快捷，一键发布；缺点也很明显，不能自己控制 commit 信息，但大多数时候都不需要给博客加什么commit信息吧，需要的时候手动 git add/git commit 即可\nMSG := \u0026#34;BLOG_TIME:\u0026#34; MSG += $(shell date) all: @hugo \u0026amp;\u0026amp; \\ if git add --all \u0026amp;\u0026amp; git commit -m \u0026#34;$(MSG)\u0026#34;; then \\ git push \u0026amp;\u0026amp; echo \u0026#34;\\033[32mBlog Repo Success!\\033[0m\u0026#34;;\\ else \\ echo \u0026#34;\\033[31mNothing need commit in Blog Repo\\033[0m\u0026#34;; \\ fi @cd ./public/ \u0026amp;\u0026amp; \\ if git add --all \u0026amp;\u0026amp; git commit -m \u0026#34;$(MSG)\u0026#34;; then \\ git push \u0026amp;\u0026amp; echo \u0026#34;\\033[32mPublic Repo Success!\\033[0m\u0026#34;; \\ else \\ echo \u0026#34;\\033[31mNothing need commit in Public Repo\\033[0m\u0026#34;; \\ fi .PHONY: all 代码实现 # 首先定义一个MSG变量，从Shell中获取当天日期添加到MSG中，当作 commit 信息；然后在伪目标all中添加命令，先执行hugo，生成 public 文件，接着是两个简单的if判断，分别检测 Blog 仓库和生成的 public 仓库之下有没有需要添加的更改， 如果有就 add 、commit、然后推送到远程并输出成功信息，如果没有停止并输出错误信息即可\n注意：echo中\\033[32m ... \\033[0m表示输出信息为绿色 ，\\033[31m ... \\033[0m表示输出信息为红色\n","date":"2023-11-29","permalink":"/blog/makefile-hugoblog/","section":"Blog","summary":"auto push hugo blog use make","title":"使用Makefile实现自动发布Hugo博客"},{"content":"","date":"2023-11-29","permalink":"/","section":"松TvT","summary":"","title":"松TvT"},{"content":"","date":"2023-11-06","permalink":"/tags/pta/","section":"Tags","summary":"","title":"PTA"},{"content":" 验证是否素数 # 先验证\\(1、2、3\\)，且\\(6=2*3\\)，接下来只需验证\\(6n-1\\)与\\(6n+1\\)\nint is_prime(int n) { if (n \u0026lt;= 1) return 0; if (n \u0026lt;= 3) return 1; if (n % 2 == 0 || n % 3 == 0) return 0; for (int i = 5; i * i \u0026lt;= n; i += 6) if (n % i == 0 || n % (i + 2) == 0) return 0; return 1; } strcpy 和 strdup 基本用法 # strcpy 和 strdup 都是用于处理字符串的 C 函数，它们的功能相似，但用法略有不同。\nstrcpy（String Copy）: strcpy 用于将一个字符串（字符数组）的内容复制到另一个字符数组中。 它的原型为 char* strcpy(char* dest, const char* src)。 dest 是目标字符串，src 是源字符串。 strcpy 将 src 的内容复制到 dest 中，直到遇到空字符 '\\0' 为止。 注意：strcpy 不会检查目标数组是否足够大来容纳源字符串的内容，这可能导致缓冲区溢出。因此，在使用 strcpy 时，必须确保目标数组足够大，以免发生溢出。 示例：\nchar source[] = \u0026#34;Hello, World!\u0026#34;; char destination[20]; strcpy(destination, source); strdup（String Duplicate）: strdup 用于复制一个字符串，并为新字符串分配足够的内存空间。 strdup 并不是标准 C 函数，但它是一种常见的库函数，通常在 POSIX 环境中可用。 strdup 的原型通常为 char* strdup(const char* str)。 它接受一个源字符串 str，并动态分配足够的内存来存储它，并将其内容复制到新分配的内存中。 返回值是指向新字符串的指针，你需要负责在使用后释放这个内存，通常使用 free 函数。 示例：\nchar source[] = \u0026#34;Hello, World!\u0026#34;; char* duplicate = strdup(source); // 使用 duplicate free(duplicate); // 释放内存，以避免内存泄漏 总结：\nstrcpy 用于在已分配的内存中复制字符串，需要手动分配目标数组的内存和确保足够大。 strdup 用于复制字符串并动态分配内存，更方便，但需要手动释放内存以避免内存泄漏。 1008 数组元素循环右移问题 # 注意\\(M\\) 可能会大于\\(N\\)，即\\(M=kN+a\\)，\\(M\\)中大于\\(N\\)的\\(kN\\)部分只是循环，并无意义， 令\\(M \\equiv M \\mod N\\)即可，接下来只要从数组的第\\(M\\)项存第一个数，\\(n - m\\)项之后开始在数组的第一位存数字\nc 语言版 #include \u0026lt;stdio.h\u0026gt; int main() { int n = 0, m = 0, q = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); m = m % n; int a[n]; for (int i = 0; i \u0026lt; n; i++) { int t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i \u0026lt; n - m) a[m + i] = t; else { a[i - (n - m)] = t; } } for (int i = 0; i \u0026lt; n; i++) { if (q == 0) { printf(\u0026#34;%d\u0026#34;, a[i]); q = 1; } else { printf(\u0026#34; %d\u0026#34;, a[i]); } } } rust版 use std::io; fn main() { let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Can\u0026#39;t read line\u0026#34;); let mut input = input.trim().split_whitespace(); let n: i32 = input.next().expect(\u0026#34;Error\u0026#34;).parse().expect(\u0026#34;Not a num\u0026#34;); let mut m: i32 = input.next().expect(\u0026#34;Error\u0026#34;).parse().expect(\u0026#34;Not a num\u0026#34;); m = m % n; let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Can\u0026#39;t read line\u0026#34;); let mut a: Vec\u0026lt;i32\u0026gt; = input .trim() .split_whitespace() .map(|n| n.parse().expect(\u0026#34;Not a num!\u0026#34;)) .collect(); let len = a.len(); let vec_move = a.split_off(len - m as usize); a.splice(0..0, vec_move); a.into_iter().enumerate().for_each(|(idx, n)| { if idx == 0 { print!(\u0026#34;{}\u0026#34;, n) } else { print!(\u0026#34; {}\u0026#34;, n); } }) } ","date":"2023-11-06","permalink":"/blog/PTA-1-20/","section":"Blog","summary":"PTA 乙级1-20题","title":"PTA 乙级1-20"},{"content":"","date":"2023-11-06","permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法"},{"content":" 说明 # 测试markdown基本元素以及一些扩展语法能否正常显示\n1.代码块 # fn collatz_steps(n: u32) -\u0026gt; Option\u0026lt;u32\u0026gt; { if n == 0 { return None; } let mut steps = 0; let mut current = n; while current != 1 { if current % 2 == 0 { current /= 2; } else { current = (3 * current + 1) / 2; } steps += 1; } Some(steps) } 2.字体 # 加粗 ==高亮== 删除线 斜体 粗斜体 下划线 红色\n3.列表 # BulletedList:- BulletedList:+ BulletedList:* Numbered List Numbered List 4.表格 # 居中 居左 居右 常规 hello hello hello hello 使用 : 可以控制居中、左、右 5.区块 # 最外层\n第一层\n第二层\n第四层\n6.分割线 # --- 2.***\n7.公式 # 已知\\(|x|+|y|=0\\), 则 $$ x=y=0 $$\n8.图片 # 插入图片的方法一 插入图片的方法二 9.链接 # bilibili\n","date":"2023-10-04","permalink":"/blog/markdown-style/","section":"Blog","summary":"markdown-style-test","title":"markdown样式测试"},{"content":"","date":"2023-10-04","permalink":"/tags/sundry/","section":"Tags","summary":"","title":"sundry"},{"content":"","date":"2023-10-04","permalink":"/tags/css/","section":"Tags","summary":"","title":"css"},{"content":"","date":"2023-10-04","permalink":"/tags/html/","section":"Tags","summary":"","title":"html"},{"content":" 1. 前言 # 不折腾会死星人，花了一个周末搭了一个简单的个人博客，用hugo生成静态网页，利用Github Pages部署； 过程很顺利，没有什么大坑，详细可以参考这个教程 如何用 GitHub Pages + Hugo 搭建个人博客\n前置需求：Git基本用法、一个GitHub账号、Google账号（如果需要配置firebase）、一点点前端知识（不会也没关系，但如果你想自己做美化会比较麻烦）\n2. 工具资源 # 以下是搭建博客中参考到的教程和资源\nhugo基本用法 firebase部署，可以提供一些交互性功能 配色参考,一个中国风配色网站 博客主题 Blowfish，PC端、移动端适配的都比较好，自定义也很方便 Godaddy域名绑定以及配置DNS，Godaddy支持支付宝付款，也可以在阿里云购买（需实名） 生成不同分辨率的 网站图标 ","date":"2023-10-04","permalink":"/blog/create-a-wesite-using-githubpages-and-hugo/","section":"Blog","summary":"如何用GitHub Pages + hugo搭建个人博客","title":"如何用GitHub Pages + hugo搭建个人博客"},{"content":" About Me # 我从 2023-11 开始写博客，第一篇博客是 我的第一篇博客 在校摸鱼大学生 About Site # 本站生日：2023-11-4 使用 Hugo 搭建，部署在 GitHub Pages 上，详细请参考： 如何用 GitHub Pages + Hugo 搭建个人博客 Now 页面的灵感来自 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect! # 如果有任何问题，或者其他想要交流的信息，我会很高兴收到你的邮件： vv.vincent.mys@gmail.com ","date":"0001-01-01","permalink":"/about/","section":"松TvT","summary":"About Me # 我从 2023-11 开始写博客，第一篇博客是 我的第一篇博客 在校摸鱼大学生 About Site # 本站生日：2023-11-4 使用 Hugo 搭建，部署在 GitHub Pages 上，详细请参考： 如何用 GitHub Pages + Hugo 搭建个人博客 Now 页面的灵感来自 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect!","title":"About"},{"content":"","date":"0001-01-01","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"0001-01-01","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":" TODO # 活过期末:( Der Mensch kann zwar tun, was er will, aber er kann nicht wollen, was er will —— Arthur Schopenhauer ","date":"0001-01-01","permalink":"/now/","section":"松TvT","summary":" TODO # 活过期末:( Der Mensch kann zwar tun, was er will, aber er kann nicht wollen, was er will —— Arthur Schopenhauer ","title":"Now"},{"content":"","date":"0001-01-01","permalink":"/series/","section":"Series","summary":"","title":"Series"}]