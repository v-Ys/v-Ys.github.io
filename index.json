
[{"content":"","date":"2024-03-29","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":" 引言 # 大多数 Scheme 教程都会推荐 Mit Scheme 作为开发环境，但在 M1 Mac 通过 Homebrew 安装mit-scheme时会得到如下错误\nbrew install mit-scheme mit-scheme: The x86_64 architecture is required for this software. Error: mit-scheme: Unsatisfied requirements failed this build. 这是因为 mit-scheme 没有为 M1 做适配，只能在 Intel 的机型运行，以下推荐两种替代方案\n1. ChezScheme # # 安装 brew install chezscheme # 进入交互环境 chez # 运行 Scheme 代码 chez --script filename.scm 2. Racket # racket 是 scheme 的一种方言，它也提供 r5rs scheme 的支持\n# 安装 brew install minimal‐racket # 安装 r5rs 支持 raco pkg install ‐‐auto r5rs # 运行 racket ‐I r5rs ‐r filename.scm 通过 hashbang 指定 r5rs 在文件顶行添加#lang r5rs,\n#lang r5rs (define (fibonacci-sum n) (define (fibonacci n) (if (\u0026lt; n 2) n (+ (fibonacci (- n 1)) (fibonacci (- n 2))))) (define (sum-fibonacci n) (if (\u0026lt; n 2) n (+ (sum-fibonacci (- n 1)) (fibonacci n)))) (sum-fibonacci n)) (display (fibonacci-sum 10)) 运行\nracket filename.scm 将 hashbang 改为 #lang racket 则是以 racket 的语法运行\n","date":"2024-03-29","externalUrl":null,"permalink":"/blog/mac-scheme-env/","section":"Blog","summary":"引言 # 大多数 Scheme 教程都会推荐 Mit Scheme 作为开发环境，但在 M1 Mac 通过 Homebrew 安装mit-scheme时会得到如下错误","title":"M1 Mac 配置 Scheme｜racket 环境","type":"blog"},{"content":"","date":"2024-03-29","externalUrl":null,"permalink":"/tags/scheme/","section":"Tags","summary":"","title":"Scheme","type":"tags"},{"content":"","date":"2024-03-29","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-03-29","externalUrl":null,"permalink":"/","section":"松TvT","summary":"","title":"松TvT","type":"page"},{"content":"","date":"2024-03-08","externalUrl":null,"permalink":"/tags/macos/","section":"Tags","summary":"","title":"MacOS","type":"tags"},{"content":"最近重装系统，记录一下新系统配置流程\n代理 \u0026amp; Homebrew # 第一步当然是安装Homebrew啦，安装Homebrew前需要先配置代理，代理工具推荐v2raya，但v2raya需要通过Homebrew安装:(, 所以记得备份一个ClashX的安装包或者从App Store安装手机版的Shadowrocket，给终端配置好代理之后执行\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 给brew添加软件源（字体和v2raya)\nbrew tap v2raya/v2raya brew tap homebrew/cask-fonts 必备App # Fliqlo，一款简约好看的Screen Saver # brew install --cask fliqlo Bob：翻译软件，支持OCR翻译 # 通过App Store（¥30）安装，也可以在GitHub下载社区版（已不再维护）\n全局搜索、脚本、改键 # brew install --cask raycast hammerspoon karabiner‐elements 解压和压缩 # brew install --cask maczip the‐unarchiver 多媒体 # brew insatll --cask iina xld IINA： 一款开源的视频播放器，部分视频格式默认的 QuickTime Player 不支持，\nXLD： 音频转码小工具，有搭建本地音乐库的打算，纯 flac 格式太耗空间，一般会转为较小的 m4a 格式\nTypora \u0026amp; Downie 4 # 最好用的 Markdown 编辑器 \u0026amp; 最好用的视频下载器（bilibili\u0026amp;YouTube），但是都付费:(\n命令行工具 # Basic Tools # brew install eza bat ripgrep fd difftastic fzf zoxide tmux cmake v2raya eza：代替ls、tree，bat：代替cat，zoxide：常用路径跳转，其他都比较常见不逐一介绍\n笔记 \u0026amp; 博客 # brew install typst hugo 开发环境 # # editor \u0026amp; terminal brew install --cask visual‐studio‐code alacritty wezterm # c/c++ brew install llvm # rust curl ‐‐proto \u0026#39;=https\u0026#39; ‐‐tlsv1.2 ‐sSf https://sh.rustup.rs | sh # golang brew install golang 系统设置 # 更改截图默认储存位置 # 同时按下 Command - Shift - 5 会弹出截屏选取框和相关设定， 点击下方的“选项”按钮，选择其他位置\n加快切屏速度 # defaults write com.apple.dock workspaces‐edge‐delay 0;killall Dock # 恢复默认 defaults delete com.apple.dock workspaces‐edge‐delay;killall Dock 关闭桌面切换动画 # 系统设置 –\u0026gt; 辅助功能 –\u0026gt; 显示 –\u0026gt; 减弱用户界面的动态效果:打开\nFinder 设置 # 显示文件后缀, choose Finder \u0026gt; Settings \u0026gt; Advancedi \u0026gt; “Show all filename extensions”\n更改 New window 默认打开文件 choose Finder \u0026gt; Settings \u0026gt; General\n将 Desktop\u0026amp;Documents 加入 iCloud Drive # Apple menu  \u0026gt; System Settings \u0026gt; Click Apple ID \u0026gt; iCloud \u0026gt; iCloud Drive. Below iCloud Drive, check that Sync this Mac is turned on. Turn on Desktop \u0026amp; Documents Folders. ","date":"2024-03-08","externalUrl":null,"permalink":"/blog/mac-config/","section":"Blog","summary":"MacOS配置流程","title":"MacOS新机配置","type":"blog"},{"content":"","date":"2023-11-29","externalUrl":null,"permalink":"/tags/make/","section":"Tags","summary":"","title":"Make","type":"tags"},{"content":" 配置使用 # 在你的 bolg 仓库下新建一个 Makefile 文件，拷贝下面的代码进去，每次写完在 blog 仓库下执行make就行，（make 一般都预装的吧，应该不需要额外安装:） 优点方便快捷，一键发布；缺点也很明显，不能自己控制 commit 信息，但大多数时候都不需要给博客加什么commit信息吧，需要的时候手动 git add/git commit 即可\nMSG := \u0026#34;BLOG_TIME:\u0026#34; MSG += $(shell date) all: @hugo \u0026amp;\u0026amp; \\ if git add --all \u0026amp;\u0026amp; git commit -m \u0026#34;$(MSG)\u0026#34;; then \\ git push \u0026amp;\u0026amp; echo \u0026#34;\\033[32mBlog Repo Success!\\033[0m\u0026#34;;\\ else \\ echo \u0026#34;\\033[31mNothing need commit in Blog Repo\\033[0m\u0026#34;; \\ fi @cd ./public/ \u0026amp;\u0026amp; \\ if git add --all \u0026amp;\u0026amp; git commit -m \u0026#34;$(MSG)\u0026#34;; then \\ git push \u0026amp;\u0026amp; echo \u0026#34;\\033[32mPublic Repo Success!\\033[0m\u0026#34;; \\ else \\ echo \u0026#34;\\033[31mNothing need commit in Public Repo\\033[0m\u0026#34;; \\ fi .PHONY: all 代码实现 # 首先定义一个MSG变量，从Shell中获取当天日期添加到MSG中，当作 commit 信息；然后在伪目标all中添加命令，先执行hugo，生成 public 文件，接着是两个简单的if判断，分别检测 Blog 仓库和生成的 public 仓库之下有没有需要添加的更改， 如果有就 add 、commit、然后推送到远程并输出成功信息，如果没有停止并输出错误信息即可\n注意：echo中\\033[32m ... \\033[0m表示输出信息为绿色 ，\\033[31m ... \\033[0m表示输出信息为红色\n","date":"2023-11-29","externalUrl":null,"permalink":"/blog/makefile-hugoblog/","section":"Blog","summary":"auto push hugo blog use make","title":"使用Makefile实现自动发布Hugo博客","type":"blog"},{"content":"","date":"2023-11-06","externalUrl":null,"permalink":"/tags/pta/","section":"Tags","summary":"","title":"PTA","type":"tags"},{"content":" 验证是否素数 # 先验证\\(1、2、3\\)，且\\(6=2*3\\)，接下来只需验证\\(6n-1\\)与\\(6n+1\\)\nint is_prime(int n) { if (n \u0026lt;= 1) return 0; if (n \u0026lt;= 3) return 1; if (n % 2 == 0 || n % 3 == 0) return 0; for (int i = 5; i * i \u0026lt;= n; i += 6) if (n % i == 0 || n % (i + 2) == 0) return 0; return 1; } strcpy 和 strdup 基本用法 # strcpy 和 strdup 都是用于处理字符串的 C 函数，它们的功能相似，但用法略有不同。\nstrcpy（String Copy）: strcpy 用于将一个字符串（字符数组）的内容复制到另一个字符数组中。 它的原型为 char* strcpy(char* dest, const char* src)。 dest 是目标字符串，src 是源字符串。 strcpy 将 src 的内容复制到 dest 中，直到遇到空字符 '\\0' 为止。 注意：strcpy 不会检查目标数组是否足够大来容纳源字符串的内容，这可能导致缓冲区溢出。因此，在使用 strcpy 时，必须确保目标数组足够大，以免发生溢出。 示例：\nchar source[] = \u0026#34;Hello, World!\u0026#34;; char destination[20]; strcpy(destination, source); strdup（String Duplicate）: strdup 用于复制一个字符串，并为新字符串分配足够的内存空间。 strdup 并不是标准 C 函数，但它是一种常见的库函数，通常在 POSIX 环境中可用。 strdup 的原型通常为 char* strdup(const char* str)。 它接受一个源字符串 str，并动态分配足够的内存来存储它，并将其内容复制到新分配的内存中。 返回值是指向新字符串的指针，你需要负责在使用后释放这个内存，通常使用 free 函数。 示例：\nchar source[] = \u0026#34;Hello, World!\u0026#34;; char* duplicate = strdup(source); // 使用 duplicate free(duplicate); // 释放内存，以避免内存泄漏 总结：\nstrcpy 用于在已分配的内存中复制字符串，需要手动分配目标数组的内存和确保足够大。 strdup 用于复制字符串并动态分配内存，更方便，但需要手动释放内存以避免内存泄漏。 1008 数组元素循环右移问题 # 注意\\(M\\) 可能会大于\\(N\\)，即\\(M=kN+a\\)，\\(M\\)中大于\\(N\\)的\\(kN\\)部分只是循环，并无意义， 令\\(M \\equiv M \\mod N\\)即可，接下来只要从数组的第\\(M\\)项存第一个数，\\(n - m\\)项之后开始在数组的第一位存数字\nc 语言版 #include \u0026lt;stdio.h\u0026gt; int main() { int n = 0, m = 0, q = 0; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); m = m % n; int a[n]; for (int i = 0; i \u0026lt; n; i++) { int t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); if (i \u0026lt; n - m) a[m + i] = t; else { a[i - (n - m)] = t; } } for (int i = 0; i \u0026lt; n; i++) { if (q == 0) { printf(\u0026#34;%d\u0026#34;, a[i]); q = 1; } else { printf(\u0026#34; %d\u0026#34;, a[i]); } } } rust版 use std::io; fn main() { let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Can\u0026#39;t read line\u0026#34;); let mut input = input.trim().split_whitespace(); let n: i32 = input.next().expect(\u0026#34;Error\u0026#34;).parse().expect(\u0026#34;Not a num\u0026#34;); let mut m: i32 = input.next().expect(\u0026#34;Error\u0026#34;).parse().expect(\u0026#34;Not a num\u0026#34;); m = m % n; let mut input = String::new(); io::stdin().read_line(\u0026amp;mut input).expect(\u0026#34;Can\u0026#39;t read line\u0026#34;); let mut a: Vec\u0026lt;i32\u0026gt; = input .trim() .split_whitespace() .map(|n| n.parse().expect(\u0026#34;Not a num!\u0026#34;)) .collect(); let len = a.len(); let vec_move = a.split_off(len - m as usize); a.splice(0..0, vec_move); a.into_iter().enumerate().for_each(|(idx, n)| { if idx == 0 { print!(\u0026#34;{}\u0026#34;, n) } else { print!(\u0026#34; {}\u0026#34;, n); } }) } ","date":"2023-11-06","externalUrl":null,"permalink":"/blog/PTA-1-20/","section":"Blog","summary":"PTA 乙级1-20题","title":"PTA 乙级1-20","type":"blog"},{"content":"","date":"2023-11-06","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":" 说明 # 测试markdown基本元素以及一些扩展语法能否正常显示\n1.代码块 # fn collatz_steps(n: u32) -\u0026gt; Option\u0026lt;u32\u0026gt; { if n == 0 { return None; } let mut steps = 0; let mut current = n; while current != 1 { if current % 2 == 0 { current /= 2; } else { current = (3 * current + 1) / 2; } steps += 1; } Some(steps) } 2.字体 # 加粗 ==高亮== 删除线 斜体 粗斜体 下划线 红色\n3.列表 # BulletedList:- BulletedList:+ BulletedList:* Numbered List Numbered List 4.表格 # 居中 居左 居右 常规 hello hello hello hello 使用 : 可以控制居中、左、右 5.区块 # 最外层\n第一层\n第二层\n第四层\n6.分割线 # --- 2.***\n7.公式 # 已知\\(|x|+|y|=0\\), 则 $$ x=y=0 $$\n8.图片 # 插入图片的方法一 插入图片的方法二 9.链接 # bilibili\n","date":"2023-10-04","externalUrl":null,"permalink":"/blog/markdown-style/","section":"Blog","summary":"markdown-style-test","title":"markdown样式测试","type":"blog"},{"content":"","date":"2023-10-04","externalUrl":null,"permalink":"/tags/sundry/","section":"Tags","summary":"","title":"Sundry","type":"tags"},{"content":"","date":"2023-10-04","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"Css","type":"tags"},{"content":"","date":"2023-10-04","externalUrl":null,"permalink":"/tags/html/","section":"Tags","summary":"","title":"Html","type":"tags"},{"content":" 1. 前言 # 不折腾会死星人，花了一个周末搭了一个简单的个人博客，用hugo生成静态网页，利用Github Pages部署； 过程很顺利，没有什么大坑，详细可以参考这个教程如何用 GitHub Pages + Hugo 搭建个人博客\n前置需求：Git基本用法、一个GitHub账号、Google账号（如果需要配置firebase）、一点点前端知识（不会也没关系，但如果你想自己做美化会比较麻烦）\n2. 工具资源 # 以下是搭建博客中参考到的教程和资源\nhugo基本用法 firebase部署，可以提供一些交互性功能 配色参考,一个中国风配色网站 博客主题Blowfish，PC端、移动端适配的都比较好，自定义也很方便 Godaddy域名绑定以及配置DNS，Godaddy支持支付宝付款，也可以在阿里云购买（需实名） 生成不同分辨率的网站图标 ","date":"2023-10-04","externalUrl":null,"permalink":"/blog/create-a-wesite-using-githubpages-and-hugo/","section":"Blog","summary":"如何用GitHub Pages + hugo搭建个人博客","title":"如何用GitHub Pages + hugo搭建个人博客","type":"blog"},{"content":" About Me # 我从 2023-11 开始写博客，第一篇博客是我的第一篇博客 在校摸鱼大学生 About Site # 本站生日：2023-11-4 使用 Hugo 搭建，部署在 GitHub Pages 上，详细请参考：如何用 GitHub Pages + Hugo 搭建个人博客 Now 页面的灵感来自 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect! # 如果有任何问题，或者其他想要交流的信息，我会很高兴收到你的邮件：vv.vincent.mys@gmail.com ","externalUrl":null,"permalink":"/about/","section":"松TvT","summary":"About Me # 我从 2023-11 开始写博客，第一篇博客是我的第一篇博客 在校摸鱼大学生 About Site # 本站生日：2023-11-4 使用 Hugo 搭建，部署在 GitHub Pages 上，详细请参考：如何用 GitHub Pages + Hugo 搭建个人博客 Now 页面的灵感来自 Derek Sivers Don\u0026rsquo;t be shy, let\u0026rsquo;s connect!","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Der Mensch kann zwar tun, was er will, aber er kann nicht wollen, was er will —— Arthur Schopenhauer TODO # 会好起来的:( ","externalUrl":null,"permalink":"/now/","section":"松TvT","summary":" Der Mensch kann zwar tun, was er will, aber er kann nicht wollen, was er will —— Arthur Schopenhauer TODO # 会好起来的:( ","title":"Now","type":"page"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]